import os
import numpy as np
import pandas as pd
from tqdm import tqdm
import configargparse

'''
This script is used to process eqtl data and obtain a negative dataset based on eqtl data

The input 1000 person genome data is a 1kgp_maF>0.01.csv file generated by handle_1kgp.py
The input eqtl data should be the CSV data obtained through "filter_comding. R", for example: "/mnt/data0/users/lisg/Data/eqtl/eqtl_acc/coding_filter.csv"
Eqtl output: Save the three negative data files corresponding to the positive result in CSV format in the same directory as the input CSV file

The script can simultaneously select one million SNPs from the genomes of thousands of people
'''
def make_parser():
    parser = configargparse.ArgParser(description="Preprocessing eqtl data")
    parser.add_argument('--eqtl_data', type=str, default=None,
                        help='eqtl data path, must have File name. e.g.:/path/xx.csv')
    parser.add_argument('--kgp_data', type=str, default='/mnt/data0/users/lisg/Data/1kgp/1kgp_MAF>0.01.csv',
                        help='1kgp data(filter coding and MAF>0.01 , must have File name.'
                        'e.g.:/mnt/data0/users/lisg/Data/1kgp/1kgp_MAF>0.01.csv')

    parser.add_argument('--random_million', type=str, default=False,
                        help='Whether to randomly select one million 1kgp snp,default:False')
    return parser
def select_million(kgp_df,seed,output):

    np.random.seed(seed)

    total_rows = kgp_df.shape[0]

    sample_indices = np.random.choice(total_rows, size=1000000, replace=False)
    sampled_df = kgp_df.iloc[sample_indices]

    sampled_df.to_csv('%srandom_million_1kgp.csv' % output, index=False)
def main():
    parser = make_parser()
    args = parser.parse_args()
    seed = 10
    kgp_df = pd.read_csv(args.kgp_data)

    if args.random_million:

        # select_million(kgp_df=kgp_df, seed=seed, output=kgp_output)
    else:
        np.random.seed(seed)
        eqtl_df = pd.read_csv(args.eqtl_data)
        eqtl_df.columns =['variant_id','chr','variant_pos','ref','alt','rs_id_dbSNP151_GRCh38p7','maf']

        eqtl_df = eqtl_df[eqtl_df['maf'] >= 0.01] 

        bins = [0, 0.025, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50]
        labels = ['(0-0.025]', '(0.025-0.05]', '(0.05-0.10]', '(0.10-0.15]', '(0.15-0.20]', '(0.20-0.25]',
                  '(0.25-0.30]','(0.30-0.35]', '(0.35-0.40]', '(0.40-0.45]', '(0.45-0.50]']
        eqtl_df['maf_group'] = pd.cut(eqtl_df['maf'], bins=bins, labels=labels, right=True)
        eqtl_dis = eqtl_df['maf_group'].value_counts(sort=False, normalize=True)

        kgp_df['maf_group'] = pd.cut(kgp_df['AF_adjust'], bins=bins, labels=labels, right=True)



        subset_ratio =[0.008, 0.2, 1]  #[1, 0.2, 0.008]
        max_distance =[150000, 8000, 2000]  #[2000, 8000, 150000]
        target_folder = os.path.dirname(args.eqtl_data)  

        eqtl_df.to_csv('%s/positive.csv'% target_folder,index=False)

        for ratio, max_distance in zip(subset_ratio, max_distance):
           

            subset_size = int(len(kgp_df) * ratio)

            subset_list = []

            for group in labels:
                group_size = int(subset_size * eqtl_dis[group]) #
                group_df = kgp_df[kgp_df['maf_group'] == group]
                if len(group_df) >= group_size:
                    sampled_group = group_df.sample(n=group_size, replace=False, random_state=seed)
                else:


                    sampled_group = pd.concat([group_df, group_df.sample(n=group_size - len(group_df), replace=True, random_state=seed)], ignore_index=True)
                subset_list.append(sampled_group)

            subset = pd.concat(subset_list, ignore_index=True)


            if len(subset) > subset_size:

                subset = subset.sample(n=subset_size, replace=False, random_state=seed)
            elif len(subset) < subset_size:

                additional = kgp_df.sample(n=subset_size - len(subset), replace=False, random_state=seed)
                subset = pd.concat([subset, additional], ignore_index=True)

            subset = subset.sample(frac=1, random_state=seed).reset_index(drop=True)

            subset_distribution = subset['maf_group'].value_counts(sort=False, normalize=True)

            comparison = pd.DataFrame({
                'Positive': eqtl_dis,
                'Subset': subset_distribution
            })
            print(comparison)
            '''==============================================================='''

            result_df = pd.DataFrame(columns=['Chr', 'pos', 'ref', 'alt', 'AF', 'AF_adjust', 'maf_group'])
            a, b, c, d = 0, 0, 0, 0
            for i in tqdm(range(eqtl_df.shape[0])):
                row = eqtl_df.iloc[i]
                chr_value = row['chr']
                pos_value = row['variant_pos']
                ref_value = row['ref']
                alt_value = row['alt']

                filtered_subset = subset[subset['Chr'] == chr_value]

                if not filtered_subset.empty:

                    distances = (filtered_subset['pos'] - pos_value).abs()

                    filtered_subset = filtered_subset.assign(distance=distances)
                    nearest_subset = filtered_subset[filtered_subset['distance'] <= max_distance].sort_values(
                        by='distance').head(1)

                    if not nearest_subset.empty:  
                        valid_nearest_B = None
                        for _, nearest_row in nearest_subset.iterrows():
                            if not (nearest_row['Chr'] == chr_value and nearest_row['pos'] == pos_value and
                                    nearest_row['ref'] == ref_value and nearest_row['alt'] == alt_value):
                                valid_nearest_B = nearest_row
                                break
                        if valid_nearest_B is not None:  
                            d = d + 1
                            new_row = pd.DataFrame(
                                [valid_nearest_B[['Chr', 'pos', 'ref', 'alt', 'AF', 'AF_adjust', 'maf_group']]])
                        else:  
                            a = a + 1
                            new_row = pd.DataFrame([{
                                'Chr': np.nan, 'pos': np.nan, 'ref': np.nan, 'alt': np.nan,
                                'AF': np.nan, 'AF_adjust': np.nan, 'maf_group': np.nan}])
                    else:  
                        b = b + 1
                        new_row = pd.DataFrame([{
                            'Chr': np.nan, 'pos': np.nan, 'ref': np.nan, 'alt': np.nan,
                            'AF': np.nan, 'AF_adjust': np.nan, 'maf_group': np.nan}])
                else:  
                    c = c + 1
                    new_row = pd.DataFrame([{
                        'Chr': np.nan, 'pos': np.nan, 'ref': np.nan, 'alt': np.nan,
                        'AF': np.nan, 'AF_adjust': np.nan, 'maf_group': np.nan}])

                result_df = pd.concat([result_df, new_row], ignore_index=True)

            result_df.to_csv( f'%s/negative{ratio}.csv'% target_folder, index=False)


if __name__ == "__main__":
    main()



